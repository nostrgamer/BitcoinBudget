# Bitcoin Budget Desktop - Simple Python Rules

## Project Overview
A **single-file Bitcoin budgeting application** using Python + Tkinter + SQLite. Maximum simplicity, minimum complexity.

**Core Principle: If you can do it in Excel with a few macros, it should be simple in code.**

## Technology Stack
- **Language**: Python 3.8+
- **GUI**: Tkinter (built-in, no dependencies)
- **Database**: SQLite (single file)
- **Deployment**: PyInstaller (single executable)
- **Target**: ~300-500 lines total in one file

## Development Rules

### File Structure (Keep It Simple)
```
bitcoin_budget/
├── bitcoin_budget.py          # Everything goes here
├── budget.db                  # SQLite database (auto-created)
├── requirements.txt           # Just PyInstaller
└── README.md                  # Usage instructions
```

### Code Organization (Single File)
```python
# bitcoin_budget.py structure:
import sqlite3
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime, date
import calendar

# === DATABASE FUNCTIONS ===
def init_database():
    """Create tables if they don't exist"""

def add_income(amount_sats, description, date):
    """Add income transaction"""

def add_expense(amount_sats, description, category_id, date):
    """Add expense transaction"""

# === BUDGET LOGIC ===
def get_total_income(month=None):
    """Get total income for month or all time"""

def get_available_to_assign(month):
    """Calculate unallocated income"""

def get_category_balance(category_id, month):
    """Get envelope balance with rollover"""

# === GUI CLASSES ===
class BitcoinBudgetApp:
    def __init__(self):
        """Main application window"""

    def create_widgets(self):
        """Build the interface"""

    def refresh_display(self):
        """Update all displays"""

# === MAIN ===
if __name__ == "__main__":
    app = BitcoinBudgetApp()
    app.run()
```

### Python Style Guidelines
- **Functions**: Use `snake_case` for all functions and variables
- **Classes**: Use `PascalCase` for class names
- **Constants**: Use `UPPER_CASE` for constants
- **Docstrings**: Simple one-line docstrings for functions
- **Comments**: Only when the code isn't self-explanatory
- **Line length**: Keep under 100 characters

### Database Guidelines
- **Simple SQLite**: No ORM, just direct SQL
- **Three tables**: transactions, categories, allocations
- **Integer amounts**: Store satoshis as integers (no decimals)
- **Text dates**: Store as 'YYYY-MM-DD' strings
- **Foreign keys**: Use them for data integrity

### GUI Guidelines
- **Standard Tkinter**: No custom themes or complex layouts
- **Grid layout**: Simple grid-based positioning
- **Basic widgets**: Entry, Button, Label, Listbox, Frame
- **Error handling**: Use messagebox for user errors
- **Keep it functional**: UI follows function, not fashion

### Bitcoin-Specific Rules
- **Satoshis everywhere**: Always work in satoshis (integers)
- **Display formatting**: Show as "1,000,000 sats" or "0.01000000 BTC"
- **No decimals**: Avoid floating point for Bitcoin amounts
- **Input validation**: Ensure positive integers for amounts

### Simplicity Rules
❌ **NO** classes for simple data (use tuples/dicts)
❌ **NO** complex inheritance hierarchies
❌ **NO** design patterns unless absolutely necessary
❌ **NO** configuration files or settings management
❌ **NO** logging frameworks (use print() for debugging)
❌ **NO** external libraries beyond Python stdlib
❌ **NO** async/await unless truly needed
❌ **NO** threads or multiprocessing
❌ **NO** separate modules or packages

✅ **YES** to simple functions
✅ **YES** to direct database calls
✅ **YES** to basic error handling
✅ **YES** to readable code over clever code
✅ **YES** to copy-paste over abstraction
✅ **YES** to global variables if they simplify things

### Development Workflow
1. **Start with database**: Get SQLite working first
2. **Add core functions**: Income, expenses, categories
3. **Build basic GUI**: One window, basic layout
4. **Test everything**: Run functions in Python REPL
5. **Polish UI**: Make it usable, not pretty
6. **Build executable**: PyInstaller single file

### Error Handling
- **User errors**: Show messagebox with helpful message
- **Database errors**: Catch and show user-friendly message
- **Input validation**: Check before database operations
- **Graceful degradation**: App shouldn't crash on bad input

### Testing Strategy
- **Manual testing**: Click through the UI
- **Function testing**: Run individual functions in REPL
- **Database testing**: Check SQLite file with DB Browser
- **No unit tests**: Keep it simple for this scope

### Performance Guidelines
- **It's a personal budget app**: Performance is not critical
- **SQLite is fast enough**: No need for optimization
- **Tkinter is responsive enough**: No need for threading
- **Keep queries simple**: Basic SELECT/INSERT/UPDATE

### Bitcoin Display Formats
```python
def format_sats(satoshis):
    """Format satoshis for display"""
    return f"{satoshis:,} sats"

def format_btc(satoshis):
    """Format as BTC"""
    btc = satoshis / 100_000_000
    return f"{btc:.8f} BTC"

def parse_amount_input(text):
    """Parse user input to satoshis"""
    # Handle "1000", "1,000", "0.001 BTC", etc.
```

### Month/Date Handling
```python
def get_current_month():
    """Return current month as 'YYYY-MM'"""
    return datetime.now().strftime('%Y-%m')

def get_month_range(month_str):
    """Return start and end dates for month"""
    # '2025-06' -> ('2025-06-01', '2025-06-30')
```

### Common Patterns
```python
# Database connection (global is fine)
conn = sqlite3.connect('budget.db')

# Simple function pattern
def add_category(name):
    """Add a new spending category"""
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO categories (name) VALUES (?)", (name,))
        conn.commit()
        return True
    except sqlite3.IntegrityError:
        return False  # Duplicate name

# GUI update pattern
def refresh_categories(self):
    """Update category display"""
    self.category_listbox.delete(0, tk.END)
    categories = get_all_categories()
    for cat in categories:
        self.category_listbox.insert(tk.END, f"{cat['name']}: {format_sats(cat['balance'])}")
```

### Anti-Patterns to Avoid
❌ **Over-engineering**: Don't build for 10,000 users
❌ **Premature abstraction**: Don't create classes for everything
❌ **Complex state management**: Keep state in the database
❌ **Fancy UI frameworks**: Tkinter is sufficient
❌ **Multiple files**: One file is manageable for this scope
❌ **Configuration systems**: Hard-code reasonable defaults
❌ **Plugin architecture**: You ain't gonna need it

### Success Criteria
- ✅ **Works in one weekend**: Build and test completely
- ✅ **Single executable**: PyInstaller creates standalone app
- ✅ **Under 500 lines**: Readable in 10 minutes
- ✅ **All YNAB features**: Income, expenses, categories, allocation
- ✅ **No installation**: Just run the .exe
- ✅ **No crashes**: Handle user errors gracefully

### Example Function
```python
def get_category_balance(category_id, month):
    """Get current balance for category envelope"""
    cursor = conn.cursor()
    
    # Get allocated amount for this month
    cursor.execute("""
        SELECT amount FROM allocations 
        WHERE category_id = ? AND month = ?
    """, (category_id, month))
    allocated = cursor.fetchone()
    allocated = allocated[0] if allocated else 0
    
    # Get spent amount for this month
    start_date = f"{month}-01"
    end_date = f"{month}-{calendar.monthrange(int(month[:4]), int(month[5:]))[1]}"
    cursor.execute("""
        SELECT SUM(amount) FROM transactions 
        WHERE category_id = ? AND type = 'expense' 
        AND date BETWEEN ? AND ?
    """, (category_id, start_date, end_date))
    spent = cursor.fetchone()
    spent = spent[0] if spent and spent[0] else 0
    
    # Get previous month balance (simplified rollover)
    # ... rollover logic here ...
    
    return allocated - spent  # Simplified
```

Remember: **Simple is better than complex. Complex is better than complicated. Flat is better than nested.** 