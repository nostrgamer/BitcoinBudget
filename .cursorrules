# Bitcoin Budget - Streamlit Web Application Rules

## Project Overview
A **modern, web-based Bitcoin budgeting application** using Python + Streamlit + Plotly + Session State. Account-based envelope budgeting with advanced analytics.

**Core Principle: If you can do it in Excel with a few macros, it should be simple in code - now with a modern web interface and account-based budgeting.**

## Technology Stack
- **Language**: Python 3.8+
- **Web Framework**: Streamlit (modern web UI)
- **Charts**: Plotly (interactive visualizations)
- **Data**: Pandas + Session State (privacy-focused, no database)
- **Storage**: Session-based isolation (each user has private data)
- **Deployment**: Streamlit Cloud with auto-deploy from GitHub
- **Target**: ~2400 lines total across 2 files (main app + reports)

## Development Rules

### File Structure (Clean Web Architecture)
```
bitcoin_budget/
â”œâ”€â”€ streamlit_app.py           # Main application (~2400 lines)
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ __init__.py           # Package initialization
â”‚   â””â”€â”€ reports.py            # All reports functionality (~1000 lines)
â”œâ”€â”€ requirements.txt          # Streamlit + dependencies
â”œâ”€â”€ README.md                 # Complete documentation
â””â”€â”€ .cursorrules             # Development guidelines
```

### Code Organization (Streamlit Structure)
```python
# streamlit_app.py structure:
import streamlit as st
import sqlite3
import pandas as pd
from datetime import datetime, timedelta
import calendar
import plotly.express as px
import plotly.graph_objects as go

# === STREAMLIT PAGE CONFIG ===
st.set_page_config(page_title="Bitcoin Budget", layout="wide")

# === SESSION STATE FUNCTIONS ===
def initialize_session_state():
    """Initialize user data in session state"""

def add_account(name, initial_balance, is_tracked=True):
    """Add Bitcoin account (tracked/untracked)"""

def add_income(amount_sats, description, date, account_id):
    """Add income transaction with account tracking"""

def add_expense(amount_sats, description, category_id, date, account_id):
    """Add expense transaction with account tracking"""

# === ACCOUNT-BASED BUDGET LOGIC ===
def get_tracked_account_balance():
    """Get total balance of tracked accounts"""

def get_available_to_assign():
    """Calculate: Tracked Balance - Money in Categories"""

def get_category_balance(category_id):
    """Get category balance (all-time allocated - spent)"""

# === STREAMLIT UI FUNCTIONS ===
def initialize_session_state():
    """Initialize Streamlit session state"""

def main_page():
    """Main budget application page"""

def sidebar_navigation():
    """Sidebar for navigation and month selection"""

# === MAIN ===
if __name__ == "__main__":
    main()
```

### Python Style Guidelines
- **Functions**: Use `snake_case` for all functions and variables
- **Classes**: Use `PascalCase` for class names
- **Constants**: Use `UPPER_CASE` for constants
- **Docstrings**: Simple one-line docstrings for functions
- **Comments**: Only when the code isn't self-explanatory
- **Line length**: Keep under 100 characters

### Session State Guidelines
- **Privacy-First**: Each user gets isolated data in st.session_state.user_data
- **Account-Based**: Tracked (on-budget) and untracked (off-budget) accounts
- **Four data structures**: accounts, transactions, categories, allocations
- **Integer amounts**: Store satoshis as integers (no decimals)
- **Text dates**: Store as 'YYYY-MM-DD' strings
- **Account tracking**: All transactions linked to specific accounts

### Streamlit UI Guidelines
- **Built-in components**: Use st.form, st.columns, st.tabs, st.sidebar
- **Interactive widgets**: Date inputs, selectboxes, sliders with validation
- **Data display**: st.dataframe, st.metric, st.plotly_chart
- **Layout**: Wide layout with responsive columns
- **Navigation**: Sidebar with session state management
- **Error handling**: Use st.error, st.warning, st.success for user feedback

### Bitcoin-Specific Rules
- **Satoshis everywhere**: Always work in satoshis (integers)
- **Display formatting**: Show as "1,000,000 sats" or "0.01000000 BTC"
- **No decimals**: Avoid floating point for Bitcoin amounts
- **Input validation**: Ensure positive integers for amounts

### Simplicity Rules
âŒ **NO** complex state management beyond st.session_state
âŒ **NO** custom CSS or complex styling
âŒ **NO** external APIs or integrations
âŒ **NO** authentication systems
âŒ **NO** databases or persistent storage
âŒ **NO** async/await unless truly needed
âŒ **NO** complex JavaScript or custom components

âœ… **YES** to simple Streamlit functions
âœ… **YES** to session state for data storage
âœ… **YES** to built-in Streamlit components
âœ… **YES** to Plotly for charts (built-in integration)
âœ… **YES** to session state for navigation
âœ… **YES** to pandas DataFrames for data display
âœ… **YES** to responsive layouts with st.columns
âœ… **YES** to account-based budgeting patterns

### Development Workflow
1. **Start with session state**: Initialize user data structure
2. **Add account functions**: Tracked/untracked account management
3. **Add core functions**: Income, expenses, categories with account tracking
4. **Build Streamlit pages**: Main app with accounts tab and sidebar navigation
5. **Add reports module**: Separate file for 5 types of analytics
6. **Test in browser**: Run `streamlit run streamlit_app.py` locally
7. **Deploy to web**: Auto-deploy to Streamlit Cloud via GitHub

### Error Handling
- **User errors**: Show st.error with helpful message
- **Session state errors**: Catch and initialize missing data
- **Input validation**: Check before session state operations
- **Form validation**: Use Streamlit form submission patterns
- **Graceful degradation**: App shouldn't crash on bad input
- **Account validation**: Ensure account exists before transactions

### Testing Strategy
- **Manual testing**: Click through the web interface
- **Function testing**: Run individual functions in REPL
- **Session state testing**: Check data structure integrity
- **Browser testing**: Test responsiveness and mobile compatibility
- **Multi-user testing**: Verify session isolation works properly
- **No unit tests**: Keep it simple for this scope

### Performance Guidelines
- **Personal budget app**: Performance is not critical
- **Session state is fast**: In-memory operations are instant
- **Streamlit handles caching**: Use @st.cache_data when needed
- **Keep operations simple**: Basic list/dict operations
- **Pandas for display**: DataFrame operations are efficient enough
- **Account balance caching**: Store computed balances to avoid recalculation

### Bitcoin Display Formats
```python
def format_sats(satoshis):
    """Format satoshis for display"""
    return f"{satoshis:,} sats"

def format_btc(satoshis):
    """Format as BTC"""
    btc = satoshis / 100_000_000
    return f"{btc:.8f} BTC"

def parse_amount_input(text):
    """Parse user input to satoshis"""
    # Handle "1000", "1,000", "0.001 BTC", etc.
```

### Streamlit-Specific Patterns
```python
# Session state initialization with user data
def initialize_session_state():
    if 'user_data' not in st.session_state:
        st.session_state.user_data = {
            'accounts': [demo_accounts],
            'transactions': [demo_transactions],
            'categories': [demo_categories],
            'allocations': [demo_allocations]
        }

# Account-based form handling
with st.form("add_income_form"):
    amount = st.text_input("Amount", placeholder="1000000 or 0.01 BTC")
    description = st.text_input("Description")
    account = st.selectbox("Account", [acc['name'] for acc in get_accounts()])
    submitted = st.form_submit_button("Add Income")
    
    if submitted and amount and description and account:
        try:
            amount_sats = parse_amount_input(amount)
            account_id = get_account_id_by_name(account)
            if add_income(amount_sats, description, date.today(), account_id):
                st.success("Income added successfully!")
                st.rerun()
        except ValueError:
            st.error("Invalid amount format")

# Advanced analytics charts
fig = make_subplots(rows=2, cols=2, subplot_titles=(...))
# Bitcoin price growth, stack value, purchasing power, multipliers
st.plotly_chart(fig, use_container_width=True)

# Navigation with multiple report types
with st.sidebar:
    if st.button("ğŸš€ Net Worth Future Value"):
        st.session_state.page = 'reports'
        st.session_state.report_type = 'net_worth_future_value'
        st.rerun()
```

### Anti-Patterns to Avoid
âŒ **Over-engineering**: Don't build complex multi-page apps
âŒ **Custom components**: Stick to built-in Streamlit widgets
âŒ **Complex state**: Keep state in database and session_state only
âŒ **External dependencies**: Minimize additional packages
âŒ **Custom styling**: Use default Streamlit appearance
âŒ **Multiple files**: Limit to main app + reports module

### Success Criteria
- âœ… **Works in browser**: Accessible via web interface
- âœ… **Mobile friendly**: Responsive design works on phones/tablets
- âœ… **Interactive charts**: Plotly visualizations with hover details
- âœ… **Fast development**: Build and test quickly with hot reload
- âœ… **Easy deployment**: Auto-deploy to Streamlit Cloud from GitHub
- âœ… **Account-based budgeting**: Tracked and untracked accounts with transfers
- âœ… **All YNAB features**: Income, expenses, categories, allocation with accounts
- âœ… **Advanced analytics**: 5 report types with Bitcoin Power Law projections
- âœ… **Privacy-first**: Session-based isolation for each user
- âœ… **Motivational**: Net Worth Future Value to encourage stacking
- âœ… **No crashes**: Handle user errors gracefully

### Example Streamlit Function
```python
def main_page():
    """Main budget application page with account-based budgeting"""
    current_month = st.session_state.current_month
    
    st.title(f"â‚¿ Bitcoin Budget - {current_month}")
    
    # Account-based budget summary metrics
    tracked_balance = get_total_account_balance(tracked_only=True)
    in_categories = get_total_category_balances_current()
    available = tracked_balance - in_categories
    
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Tracked Account Balance", format_sats(tracked_balance))
    with col2:
        st.metric("Money in Categories", format_sats(in_categories))
    with col3:
        st.metric("Available to Assign", format_sats(available))
    
    # Tabbed interface with accounts
    tab1, tab2, tab3, tab4 = st.tabs(["ğŸ¦ Accounts", "ğŸ“ Categories", "ğŸ’³ Transactions", "ğŸ“Š Reports"])
    
    with tab1:
        # Account management with tracked/untracked designation
        accounts_page()
```

Remember: **Simple is better than complex. Account-based is better than transaction-only. Privacy-first is better than shared data. Motivational is better than purely functional.**

## Database Integration Roadmap

### ğŸ¯ **Current Development**: Hybrid Storage Solution
**Branch**: `1-database-integration-that-allows-local-and-csv-formats`

The current session-only storage provides maximum privacy but lacks persistence. We're implementing a hybrid solution that maintains Bitcoin privacy ethos while adding practical data persistence and portability.

### ğŸš€ **Phase 1: localStorage Persistence** (ğŸš§ In Progress)
**Goal**: Replace SQLite with browser localStorage for automatic session persistence

**Implementation Tasks**:
- âœ… Remove SQLite database dependencies
- âœ… Create localStorage wrapper functions for data operations
- âœ… Migrate all session_state operations to localStorage
- âœ… Add automatic save/load on app initialization
- âœ… Maintain same privacy benefits (data never leaves user's device)
- âœ… Add localStorage error handling and fallback to session_state

**Technical Changes**:
```python
# Replace SQLite operations with localStorage
def save_to_local_storage(key, data):
    """Save data to browser localStorage"""
    
def load_from_local_storage(key, default=None):
    """Load data from browser localStorage with fallback"""
    
def initialize_session_state():
    """Load existing data from localStorage or create demo data"""
```

### ğŸ“‚ **Phase 2: JSON Export/Import** (â³ Planned)
**Goal**: Allow users to export/import their budget data as JSON files

**Implementation Tasks**:
- âœ… Create export function: budget data â†’ JSON file download
- âœ… Create import function: JSON file upload â†’ restore budget data
- âœ… Add data validation and error handling for imports
- âœ… Support partial imports (accounts only, transactions only, etc.)
- âœ… Add backup/restore functionality in UI (sidebar or settings)

### ğŸ“Š **Phase 3: YNAB CSV Import** (â³ Planned) 
**Goal**: Enable easy migration from YNAB to Bitcoin Budget

**Implementation Tasks**:
- âœ… Parse YNAB CSV export format
- âœ… Map YNAB accounts â†’ Bitcoin accounts (tracked/untracked)
- âœ… Map YNAB categories â†’ Bitcoin Budget categories
- âœ… Convert USD amounts â†’ satoshis (user-specified or current rate)
- âœ… Handle YNAB-specific data (payees, cleared status, etc.)
- âœ… Add YNAB import UI with preview and mapping options

**YNAB CSV Mapping**:
```python
# YNAB CSV columns â†’ Bitcoin Budget fields
def parse_ynab_csv(csv_data, btc_usd_rate):
    """Convert YNAB export to Bitcoin Budget format"""
    # Account â†’ Account (create tracked/untracked)
    # Category Group â†’ Master Category
    # Category â†’ Category
    # Outflow/Inflow â†’ Amount in satoshis
    # Date, Payee, Memo â†’ Transaction details
```

### ğŸ“ **Phase 4: Enhanced Export Formats** (â³ Planned)
**Goal**: Support multiple export formats for different use cases

**Implementation Tasks**:
- âœ… CSV export for analysis/spreadsheets
- âœ… YNAB-compatible CSV export (for reverse migration)
- âœ… PDF reports export
- âœ… Multiple file format selection in export UI

### ğŸ”„ **Development Guidelines for Database Integration**

**localStorage Implementation**:
- **Use JSON serialization**: Store complex objects as JSON strings
- **Error handling**: Graceful fallback to session_state if localStorage fails
- **Data validation**: Ensure data integrity on load
- **Privacy maintained**: localStorage is still client-side only

**File Operations**:
- **Streamlit file widgets**: Use st.file_uploader and st.download_button
- **User feedback**: Clear success/error messages for import/export
- **Data validation**: Validate imports before applying to prevent corruption
- **Backup reminders**: Encourage users to export regularly

**YNAB Compatibility**:
- **Pandas for CSV**: Use pd.read_csv for robust parsing
- **Currency conversion**: Flexible USD â†’ satoshis conversion options
- **Data mapping**: Clear mapping of YNAB concepts to Bitcoin Budget
- **Preview mode**: Show import preview before final confirmation

### ğŸ¯ **Success Criteria**
- âœ… **Seamless UX**: Works like native app with automatic persistence
- âœ… **Data ownership**: Users control their budget files completely
- âœ… **YNAB migration**: Easy path for existing YNAB users
- âœ… **Privacy preserved**: No server-side storage, user controls all data
- âœ… **No data loss**: Automatic saves prevent work loss
- âœ… **Cross-device**: Import/export enables device portability 